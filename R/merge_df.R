#' Extend the quotes in the Article-dataset using the passages from the Evidence-dataset.
#'
#' This function takes an Article-dataset created by create_df and an Evidence-dataset created by create_df_2 and gives back an Article-dataset with extended quotes. The files used in the example below are available on the GitHub repository in a folder named "toy". Before executing the example code you should apply convert_doc, create_df and create_df_2 on the repective files. The Article-dataset generated by create_df and the Evidence-dataset you want to use, generated by convert_doc and create_df_2 should be loaded in your Global Environment before you use the function. For further informations see https://github.com/ATSzimmat/mlwdw26. All citations for which the function found no matching partner are saved in a CSV file, always named "fehler.csv". The source of the error that led to the missing partner is explicitly indicated. All quotes from the Article-dataset for which no suitable partner could be found are stored separately in a CSV-file named "fehler.csv", including metadata, and the conditions that were met or not met are explicitly stated. All quotes for which the function found multiple possible partners are saved in a CSV file, always named "nicht_eindeutig.csv".
#'
#' @param lem_dat an article dataset created by create_df
#' @param bel_dat an evidence dataset created by create_df_2
#' @returns an article dataset with extended citations
#' @export
#' @examples
#' # Extend the Citations of the Article-dataset
#' final_df <- merge_df(lem_dat = toy_artikel , bel_dat = toy_belege)
#' # View the new Article-dataset
#' View(final_df)
#' # View the quotes with no suitable partner
#' errors <- readr::read_csv("fehler.csv")
#' View(errors)
#' # View the quotes with several possible partners
#' ambiguous <- readr::read_csv("nicht_eindeutig.csv")
#' View(ambiguous)
#'
merge_df <- function(lem_dat, bel_dat) {
  lem_dat <- lem_dat %>%
    # Suchmuster definieren
    dplyr::mutate(
      # Suchmuster für Bedingung B
      stelle_clean = stringr::str_trim(stelle),
      # Suchmuster für Bedingung A
      pattern_A = purrr::map_chr(stringr::str_split(zitat, "\\s+"), ~{
        w <- .x[.x != ""]
        if(length(w) == 0) return(NA_character_)
        paste0("(?i)", paste0(w, collapse = ".*"))
      }),
      # Suchmuster für Bedingung C
      cond_C = stringr::str_count(zitat, "\\S+") >= 4,
      # Suchmuster für B_vermindert
      stelle_v = stringr::str_split(stelle_clean, "\\s+") %>% purrr::map_chr(~.x[1])
    )
  # Suchmuster für Bedingung B und B_vermindert in den Belegdaten (Indices für Beschleunigung)
  bel_dat <- bel_dat %>%
    dplyr::mutate(
      stelle_clean = stringr::str_trim(pruef_stelle),
      stelle_v = stringr::str_split(stelle_clean, "\\s+") %>% purrr::map_chr(~.x[1])
    )
  index_full <- base::split(base::seq_len(base::nrow(bel_dat)), bel_dat$stelle_clean)
  index_vermindert <- base::split(base::seq_len(base::nrow(bel_dat)), bel_dat$stelle_v)
  # Prüfregeln definieren
  # Hilfsfunktion für Prüfen Bedingung D
  check_D_internal <- function(pb, lemma) {
    if (base::is.na(pb) || base::is.na(lemma) || base::nchar(lemma) < 4) return(FALSE)
    prefix <- base::tolower(base::substr(lemma, 1, 4))
    words <- stringr::str_split(base::tolower(pb), "\\s+")[[1]]
    base::any(base::substr(words, 1, 4) == prefix)
  }
  # Hilfsfunktion für uneindeutige Zitate
  evaluate_internal <- function(indices, curr_lemma, b_dat) {
    # Wenn nur doppelt, kein Problem
    if (length(indices) == 0) return(NULL)
    indices <- base::unique(indices)
    # Wenn tatsächlich uneindeutig, dann Bedingung D prüfen
    if (length(indices) == 1) return(indices[1])
    texts <- b_dat$langer_beleg[indices]
    if (length(base::unique(stats::na.omit(texts))) == 1) return(indices[1])
    d_flags <- purrr::map_lgl(indices, ~check_D_internal(b_dat$pruef_beleg[.x], curr_lemma))
    d_indices <- indices[d_flags]
    # Wenn immer noch uneindeutig, dann gibt es mehrere Kandidaten-Belege
    if (length(d_indices) == 1) return(d_indices[1])
    return(indices)
  }
  # Mit einer for-Schleife die einzelnen Bedingungen prüfen
  # Objekte definieren
  results <- base::rep(NA_character_, base::nrow(lem_dat))
  liste_fehler <- list()
  liste_mehrdeutig <- list()
  # Beginn der for-Schleife
  for (i in base::seq_len(base::nrow(lem_dat))) {
    # Statusse definieren
    status_A <- FALSE; status_B <- FALSE; status_D <- FALSE
    res <- NULL
    # Geprüfte Stellenangabe definieren
    curr_sz <- lem_dat$stelle_clean[i]
    # Geprüfte grobe Stellenangabe definieren
    curr_sz_v <- lem_dat$stelle_v[i]
    # Geprüftes Lemma definieren
    curr_lemma <- lem_dat$lemma[i]
    # Geprüften Text definieren
    p_A <- lem_dat$pattern_A[i]
    # Prüfung von C definieren
    status_C <- lem_dat$cond_C[i]
    # Prüfung auf A,B,C
    # Prüfung auf B
    cands_f <- index_full[[curr_sz]]
    if (!base::is.null(cands_f)) {
      # Prüfung auf A
      match_A_vec <- stringr::str_detect(bel_dat$pruef_beleg[cands_f], p_A)
      status_A <- base::any(match_A_vec, na.rm = TRUE)
      w_sz <- stringr::str_split(curr_sz, "\\s+")[[1]]
      match_B_vec <- purrr::map_lgl(cands_f, ~{
        w_s <- stringr::str_split(bel_dat$stelle_clean[.x], "\\s+")[[1]]
        length(w_sz) >= 3 && length(w_s) >= 3 && base::all(w_sz[1:3] == w_s[1:3])
      })
      status_B <- base::any(match_B_vec, na.rm = TRUE)
      # Wenn alle drei Bedingungen erfüllt sind, neue Zeile definieren
      curr_cands <- cands_f[base::which(match_A_vec & match_B_vec & status_C)]
      # Auf Uneindeutigkeit überprüfen
      res <- evaluate_internal(curr_cands, curr_lemma, bel_dat)
    }
    # Prüfung auf A, B_vermindert und C
    if (base::is.null(res)) {
      # Prüfung auf B_vermindert
      cands_v <- index_vermindert[[curr_sz_v]]
      # Prüfung auf A
      if (!base::is.null(cands_v)) {
        match_A_v <- stringr::str_detect(bel_dat$pruef_beleg[cands_v], p_A)
        # Prüfung auf C
        curr_cands <- cands_v[base::which(match_A_v & status_C)]
        res <- evaluate_internal(curr_cands, curr_lemma, bel_dat)
      }
    }
    # Bei eindeutigen Ergebnis, Treffer speichern
    if (base::is.numeric(res) && length(res) == 1) {
      results[i] <- bel_dat$langer_beleg[res]
    }
    else if (base::is.numeric(res) && length(res) > 1) {
      # Bei mehreren Ergebnissen, alle Kandidaten in einer Liste speichern
      for (idx in res) {
        tmp_mehr <- lem_dat[i, , drop = FALSE]
        tmp_mehr$beleg_kandidat <- bel_dat$langer_beleg[idx]
        liste_mehrdeutig[[length(liste_mehrdeutig) + 1]] <- tmp_mehr
      }
    }
    # Falls gar nichts gefunden wurde, Zitate mit Fehlern in einer Fehler-Liste speichern
    else {
      tmp_err <- lem_dat[i, , drop = FALSE]
      # tag-Liste der Statusmeldungen definieren
      tags <- c("A" = status_A, "B" = status_B, "C" = status_C, "D" = status_D)
      # Erfüllte Statusse bekommen eine Spalte
      tmp_err$erfuellt <- base::paste(names(tags)[tags], collapse = ", ")
      # Nicht-erfüllte Statusse bekommen eine Spalte
      tmp_err$nicht_erfuellt <- base::paste(names(tags)[!tags], collapse = ", ")
      # Liste der Fehler definieren
      liste_fehler[[length(liste_fehler) + 1]] <- tmp_err
    }
  }
  # Ergebnisse zum Lemmata-Dataset hinzufügen
  lem_dat$langes_zitat <- results
  # Überflüssige Spalten entfernen
  clean_cols <- c("stelle_clean", "pattern_A", "cond_C", "stelle_v")
  # Dataset mit Fehlern als CSV-Datei speichern
  if (length(liste_fehler) > 0) {
    readr::write_csv(dplyr::bind_rows(liste_fehler) %>% dplyr::select(-tidyselect::any_of(clean_cols)), "fehler.csv")
  }
  # Dataset mit uneindeutig zugeordneten Zitaten als CSV-Datei speichern
  if (length(liste_mehrdeutig) > 0) {
    readr::write_csv(dplyr::bind_rows(liste_mehrdeutig) %>% dplyr::select(-tidyselect::any_of(clean_cols)), "nicht_eindeutig.csv")
  }
  # Treffer in Dataset speichern
  final_df <- lem_dat %>%
    dplyr::filter(!is.na(langes_zitat)) %>%
    dplyr::select(-tidyselect::any_of(clean_cols))
  # Ergebnis erhalten
  return(final_df)
}
